---
layout: post
title:  "Problem 5: Smallest Multiple"
date:   2015-09-23 12:43:21
excerpt: |
  2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
  
  <br /><br />What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
categories: Problem_5
---

> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
> 
> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

Let's start with a brute force solution:

```
loop, start with num equals 21
  if num is divisible by all numbers 1..20
    return num
  otherwise, increment num
```

In Code:

{% highlight js %}
function smallestMultipleFrom1ToN(n) {
  var num = n + 1;
  while (true) {
    if (numisDivisibleBy1ToN(num, n)) return num;
    num++;
  }
}
{% endhighlight %}
And now let's write numIsDivisibleBy1To20:

{% highlight js %}
function isDivisibleBy1ToN(num, n) {
  for (var i = 1; i <= n; i++) {
    if (num % i !== 0) return false;
  }
  return true;
}
{% endhighlight %}
And our solution is `smallestMultiple(20)`:

> 232792560 


This isn't a great solution, though. We have to loop over 23 million times to reach our answer, and while this doesn't take long on modern computers with GigaHertz processors, we can imagine that a similar question but applied to the numbers 1 to 100, would take much longer. In fact, I tried running it on my laptop for 2 minutes and it never returned. 

What is the time complexity of this algorithm? Complexity analysis is a bit odd for this problem. What's the input size? Would it be `20` in this case? Or would it be proportional to our actual answer, in this case `232792560`? If we define the integer input as `n` and the final answer as `m`, then our runtime is `O(n*m)`, because we loop up to our final answer, and for each number below, we have to check if it is divisible by each natural number up to `n`. Regardless, it's not good.

Let's try a different algorithm. Note that for any numbers `a` and `b`, the smallest common multiple, `c`, has the property that the prime factorisations of `a` and `b` are both subsets of the prime factorisation of `c` and `c` is the smallest number for which this is true. In other words, the prime factorisation is the smallest superset of the prime factorisations of `a` and `b`. 

That last sentence may be difficult to parse, so let's find a concrete example: take `8` and `20`. the prime factorisation of `8` is `2*2*2` and for `20` is `2*2*5`, and the smallest common multiple is `40`, whose prime factorisation is `2*2*2*5`. Notice that this prime factorisation is the smallest set of numbers that contains both the prime factorisation of `8` and the prime factorisation of `20`.

So our new algorithm is:

{% highlight js %}
for num from 1 to 20
  get prime factorisation for num
  modify LCM prime factorisation to ensure it is a superset of nums prime factorisation
return the product of lcm's prime factorization
{% endhighlight %}

In code:
{% highlight js %}
function smallestMultiple(n) {
  var lcmPrimeFactors = {};
  var primeFactors;
  for (var num = 1; num <= n; num++) {
    primeFactors = getPrimeFactors(num);
    makeSupersetOf(lcmPrimeFactors, primeFactors);
  }
  return multiplyFactors(lcmPrimeFactors);
}
{% endhighlight %}

We've got a few helper functions to write, so let's start with `getPrimeFactors`. 

{% highlight js %}
function getPrimeFactors(num) {
  var factors = {};
  var factor = 2;
  while (factor <= num) {
    if (num % factor === 0) {
      if (!factors[factor]) factors[factor] = 1;
      else factors[factor]++;
      num = num / factor;
    }
    else factor++
  }
  return factors;
}
{% endhighlight %}

Now let's write our `makeSupersetOf` function, which will take an existing prime factorisation and a new prime Factorisation and modify the existing one to ensure it is a superset of the new one.

{% highlight js %}
function makeSupersetOf(factors, newFactors) {
  for (var key in newFactors) {
    if (!factors[key] || newFactors[key] > factors[key]) {
      factors[key] = newFactors[key];
    }
  }
  return factors;
}
{% endhighlight %}

And finally we can write `multiplyFactors`, which takes a factorisation and multiplies the factors together to return the original number.

{% highlight js %}
function multiplyFactors(factors) {
  var num = 1;
  for (var key in factors) {
    num *= Math.pow(key, factors[key]);
  }
  return num;
}
{% endhighlight %}

Using this algorithm, we get `smallestMultiple(20)`:

> 232792560 

It also works for all numbers from 1 to 100, `smallestMultiple(100)`, which never returned using our last algorithm.

> 6.972037522971249e+40

What's the time complexity for this algorithm? Again, this is a weird one. We loop for each number up to `n` and find it's prime factorisation. What the time complexity of finding a prime factorisation? Unclear exactly, but it's clearly sublinear. So the time complexity is roughly `n * sublinear(n)`, compared to `O(n*m)`. Since `m` grows hyperlinearly with `n`, this is a significantly better solution
    
    
    







