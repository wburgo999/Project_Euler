---
layout: post
title:  "Problem 7: 10001st prime"
date:   2015-09-11 12:43:21
excerpt: |
  By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
  
  <br /><br />What is the 10 001st prime number?
categories: Problem_7
---

> By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
> 
> What is the 10 001st prime number?

Let's start with the brute force solution:

```
start with num equals 2 and counter equals 0
while counter does not equal 10001
  if num is prime
    increment counter
  increment num
return num - 1 
```

We return `num - 1` to offset the final increment in the while loop. In code:

{% highlight js %}
function get10001Prime() {
  var num = 2, counter = 0;
  while (counter !== 10001) {
    if (isPrime(num)) counter++;
    num++
  }
  return num - 1
}
{% endhighlight %}

For our `isPrime` function, we loop from 1 to the square root of num and see if num is divisible by any of these numbers

{% highlight js %}
function isPrime(num) {
  var root = Math.sqrt(num);
  for (var i = 2; i <= root; i++) {
    if (num % i === 0) return false;
  }
  return true;
}
{% endhighlight %}
And our solution is, `10001Prime()`

> 104743

Notice that we have to loop through every number from `1` to `104743` and check whether it's prime by looping through each number up to its square noot. This is pretty slow; let's find a better solution. 

Initially, I thought to implement a prime seive, but a seive generates primes up to a certain number, whereas in this problem we want to generate n primes. We could simply pick a very large number for our prime seive to generate to, but let's use a more elegant solution. We can use the Prime Number Theorem:

> The number of primes not exceeding x is asymptotic to `x / log(x)`

The prime number is equivalent to: 

`nth_prime ~ n * log(n)` 

Since this is only asymptotic, meaning the nth prime may actually be slightly above or below `n * log(n)`, let's simply double the number to ensure we generate enough primes.

{% highlight js %}
function nthPrime(n) {
  var limit = 2 * (n * Math.log(n));
  var primes = primeSeive(limit);
  return primes[n - 1]; // -1 for 0 indexing
}
{% endhighlight %}

Now we can write our Prime Sieve. Why is it called a 'sieve'? You can think of the algorithm as panning for gold, where the mud is composite numbers, and primes are nuggets of gold. The algorithm sifts out the mud, leaving the gold. With the first shake of the sieve, you get rid of a lot of mud, and each subsequent shake you get rid of a bit less, but you get closer and closer to only having gold nuggest (primes) left. 

Here, I'm going to implement the prime sieve of Eratosthenes. I create an array of booleans representing all natural numbers from 1 to some predetermined limit. then I start looping with 2 and mark off each of its multiples - 4, 6, 8, 10 - all the way to the predetermined limit. By 'mark off' I mean change the boolean value in the array representing this number to false. We repeat this process for each number NOT marked false in the array. This way we only use the prime numbers, because it would be redundant to mark off multiples of composite numbers.

I made a couple small additional optimizations: you only need to loop to the square root of the predetermined limit, since all factors greater than the square root will be covered by the ones below. For a better explanation of why this is true, see my post on [Problem 21](../../../../problem_1/2015/08/20/problem-21.html). Additionally, when we mark off multiples of `n`, we can start at `n*n`, since all multiples below have already been marked off since they are of the form `n * k` where `k < n`.

{% highlight js %}
function primeSeive(limit) {
  var primes = [];
  var root = Math.sqrt(limit);
  for (var i = 0; i <= limit; i++) {
    primes[i] = true;
  }
  primes[0] = primes[1] = false // 1 and 0 are not prime

  for (var i = 2; i <= root; i++) {
    for (var j = i * i; j <= limit; j+= i) {
      primes[j] = false;
    }
  }

  return primes.map(function(e, i) { 
    if (e) return i;
    return false;
  }).filter(function(e) {
    return Boolean(e);
  });
}
{% endhighlight %}

our solution is, `nthPrime(10001)`

> 104743


